<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize variables, turns etc



//spawn enemies
if(global.battle_fixed == false)
{


    max_en=irandom(global.max_enemies -1) +1;

    global.enemy_n=max_en
    scr_spawn_enemy(global.current_enemy_type, max_en);
}
else
{
    scr_spawn_fixed();
    
    
    global.battle_fixed = false;
}

active_party = ds_list_create();
scr_spawn_party();

dead_n=0 // Number of defeated enemies
//TO DO
//make an global array for heroes, right now only has teagan in it

ally_turns = ds_list_size(active_party);         //hardcoded to 1 for now

enemy_turns = instance_number(obj_enemy);

ally_turn = true;

enemy_turn = false;
timer = 0;
turn_counter = 0;

ending = false; //boolean flag to check if the current battle phase is over
                //it won't check for dead enemies while the battle is over
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Button Handling

if (keyboard_check_pressed(vk_up)){ // Move up in Menu
    global.button-=1;
}

if (keyboard_check_pressed(vk_down)){ // Move down in Menu
    global.button+=1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Checking for dead enemies

//old method (depreciated)
/*
if(timer &gt; 100)
{
for(i=0;i&lt; ds_list_size(global.enemy);i+=1)
{ // Check for all avaible enemies

//if(global.enemy[i].alive=true&amp;&amp;global.enemy[i].time=true&amp;&amp;global.que=0){global.enemy[i].image_index=0 global.que=1 scr_damage(obj_player,global.enemy[i].dmg); global.enemy[i].time=false; global.enemy[i].alarm[0]=global.enc_en_freq+irandom(100)} // Check if enemy[i] is ready to attack
   
    check_enemy = ds_list_find_value(global.enemy, i);
    
    if (check_enemy.alive=false &amp;&amp; check_enemy.checked=false)
    { // Check if enemy[i] is dead
    
        show_debug_message("an enemy has been found dead");
        dead_n+=1; // Add to number of dead enemies
        check_enemy.checked=true; // don't check for this enemy anymore
        if(dead_n&gt;=global.enemy_n)
        { // If all enemies are defeated 
            instance_create(0,0,obj_notice);
        }
    }
    
}
}

timer++;
*/

if(ending == false)
{
    if (ds_list_empty(global.enemy))            //if the ds list is empty
    {
        ending = true;
        ds_list_destroy(global.enemy);
        instance_create(0,0, obj_notice);
    }
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Handling turns
if(ending == false)
{
enemy_turns = ds_list_size(global.enemy);
if (ally_turn == true &amp;&amp; turn_counter &gt;= ally_turns)        //if it's ally turn and turns are used up
{
    show_debug_message("It is now the enemy's turn");
    ally_turn = false;
    enemy_turn = true;
    turn_counter = 0;
}

else if (enemy_turn == true &amp;&amp; turn_counter &gt;= enemy_turns)
{
    show_debug_message("It is now the party's turn");
    ally_turn = true;
    enemy_turn = false;
    turn_counter = 0;
}

//handler for party turns
//TO DO, make modular for different members of party?
if (ally_turn == true &amp;&amp; !instance_exists(obj_battle_menu))
{
    instance_create(room_width - 200, ((room_height/100) * global.main_ui_range) + 350, obj_battle_menu);
}

else if (ally_turn == true)
{
    ally_temp = ds_list_find_value(active_party, turn_counter);
    ally_temp.isTurn = true;
}

//handler for enemy turns
else if (enemy_turn == true)
{
    enemy_turn_temp = ds_list_find_value(global.enemy, turn_counter);
    
    enemy_turn_temp.isTurn = true;

}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
